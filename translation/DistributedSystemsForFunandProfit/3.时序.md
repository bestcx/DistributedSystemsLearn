# 分布式系统	三

## time and order

​		什么是顺序,为什么他是这么重要的?

​		我们为什么一开始就这么纠结于秩序?为什么我们关心A是否发生在B之前?为什么我们不关心其他属性，比如“颜色”?让我们回到分布式系统的定义来回答这个问题。

​		你可能还记得，我将分布式编程描述为一种可以在一台计算机上使用多台计算机解决相同问题的艺术。

​		任何一次只能做一件事的系统都会创建一个总的操作顺序。就像人们通过一扇门一样，每一项业务都会有一个明确界定的(well-defined)前任(predecessor)和后继者(successor)。这基本上就是我们努力保持的编程模型。

​		传统的模型就行: 单一的程序,一个进程,一块内存空间运行在一个cpu上.操作系统抽象了可能存在多个cpu和多个程序的事实，并且计算机上的内存实际上是在多个程序之间共享的。我并不是说多线程编程和面向事件编程不存在.只是它们是传统模型之上的特殊抽象。程序的编写是按照一种有序的方式执行的:你从顶部开始，然后向下到底部。

​		顺序作为一种属性受到了如此多的关注，因为定义“正确性”的最简单方法是说“它的工作方式就像在一台机器上一样”。这通常也就意味着, a) 我们执行者相同的操作; b) 我们执行他们按照相同的顺序.即使他们是很多台机器.

​		分布式系统保持顺序(如为单个系统定义的那样)的好处是它们是通用的(generic)。你不会去担心操作是什么, 因为他们会准确的执行像一个单机系统.这很好，因为我们知道无论操作是什么，都可以使用相同的系统。

​		事实上, 一个分布式的程序运行在有多个CPU的多多个结点上, 并且会执行多个操作流.你仍然可以指定一个总顺序，但它需要精确的时钟或某种形式的通信。你可以用一个完全精确的时钟来记录每个操作，然后用它来计算出总的顺序。	或者你可能使用某种通信的系统，让它可以按照总顺序分配序号。

## 全序和偏序

​		分布式系统的自然状态是偏序的。网络和独立节点对相对顺序没有任何保证;但是在每个节点上，您可以遵循一个本地顺序。全序是一种二元关系，它定义了某个集合中每个元素的顺序。

​		当两个不同的元素中一个大于另一个时，它们就是可比较的。在偏序的集合中，有些元素对是不具有可比性的，因此偏序并不指定每个元素的确切顺序。全序和偏序都是可传递和反对称的( [antisymmetric](http://en.wikipedia.org/wiki/Antisymmetric_relation).)。对于X中所有的a、b和c，下面的语句既包含全序，也包含偏序:

> ```
> If a ≤ b and b ≤ a then a = b (antisymmetry);
> If a ≤ b and b ≤ c then a ≤ c (transitivity);
> ```
>
> 全序
>
> ```
> a ≤ b or b ≤ a (totality) for all a, b in X
> ```
>
> 偏序
>
> ```
> a ≤ a (reflexivity) for all a in X
> ```

​	

​		Git分支就是部分顺序的一个例子。你可能知道，git版本控制系统允许你从一个基本分支创建多个分支，例如从一个主分支。每个分支代表一个基于共同祖先的源代码变更历史:

> ```
> [ branch A (1,2,0)]  [ master (3,0,0) ]  [ branch B (1,0,2) ]
> [ branch A (1,1,0)]  [ master (2,0,0) ]  [ branch B (1,0,1) ]
>                   \  [ master (1,0,0) ]  /
> ```

​		分支A和B来自一个共同的祖先，但它们之间没有明确的顺序:它们代表不同的历史，不需要额外的工作(合并)就不能简化为单一的线性历史。当然，我们	可以将所有提交按任意顺序排列(例如，先按祖先顺序对它们排序，然后通过将A排序在B之前或B排序在A之前打破联系)——但如果在不存在的情况下强制执行总顺序，将丢失信息。

​		在一个由一个节点组成的系统中，必然会出现一个总的顺序:指令被执行，消息在单个程序中以特定的、可观察的顺序处理。我们已经依赖于这个全序——它使程序的执行是可预测的。这种顺序可以在分布式系统上维护，但要付出代价:通信昂贵，时间同步困难并且脆弱。

## 时间

​		时间是顺序的来源——它允许我们定义操作的顺序——巧合(coincidentally)的是，人们也可以理解时间的解释(一秒、一分钟、一天等等)。在某种意义上，时间就像任何其他整数计数器。它非常重要，以至于大多数计算机都有一个专用的时间传感器，也被称为时钟。这是如此重要，以至于我们已经想出了如何用一些不完美的物理系统(从蜡烛到铯原子)合成一个近似的相同计数器。所谓“合成”，我的意思是我们可以通过某些物理属性在物理距离较远的地方近似出整数计数器的值，而不需要直接与它通信。

​		时间戳实际上是表示世界从宇宙开始到当前时刻状态的速记值——如果某件事发生在特定的时间戳，那么它可能会受到之前发生的所有事情的影响。这个想法可以概括为一个因果时钟，它明确地跟踪原因(依赖性)，而不是简单地假设时间戳之前的一切都是相关的。当然，通常的假设是，我们只应该担心特定系统的状态，而不是整个世界。

​		假设时间在任何地方都以相同的速度前进——这是一个很大的假设，稍后我将回到这个假设——在程序中使用时间和时间戳时，有几种有用的解释。这三种解释是:

		- 顺序
		- 时长
		- 涵义



顺序. 当我们说时间是顺序的来源时,这就意味着

- 我们可以将时间戳附加到无序事件以对其进行排序
- 我们可以使用时间戳来强制操作的特定顺序或消息的传递(例如，如果一个操作到达的顺序是错误的，可以延迟它)
- 我们可以使用时间戳的值来确定某一事件是否在另一事件之前按时间顺序发生

涵义. 时间作为一种普遍可比的价值。时间戳的绝对值可以解释为日期，这对人们很有用。给定从日志文件开始停机的时间戳，您可以知道那是上周六，当时有一场雷雨。

时长. 用时间来衡量时长的与现实环境有一定的关系. 算法通常不关心时钟的绝对值或其作为日期的解释，但它们可能使用持续时间来进行一些判断调用。特别是，等待所花费的时间可以提供有关系统是分区了还是仅仅经历了高延迟的线索。

​		由于其本质，分布式系统的组件不能以可预测的方式运行。他们不保证任何特定的顺序，提前的速度，或缺乏延迟。每个节点都有一些本地顺序——因为执行(大致)是顺序的——但是这些本地顺序彼此独立。

​		强制统一顺序或者是假设一个顺序.是减少可能执行和可能发生事件的空间的一种方法。当事情可能以任何顺序发生时，人类很难进行推理——因为要考虑的排列太多了。

## 时间在任何地方都以同样的速度前进吗?

​		我们都有一个直观的时间概念，基于我们作为个体的经验。不幸的是，直观的时间概念使我们更容易描绘出完全顺序而不是部分顺序。想象事情一个接一个发生的顺序要比同时发生的容易。对单个消息顺序进行推理比对以不同顺序和不同延迟到达的消息进行推理更容易。

​		然而，在实现分布式系统时，我们希望避免对时间和顺序做出强烈的假设，因为假设越强，系统就越容易出现“时间传感器”或板载时钟的问题。此外，执行命令是要付出代价的。我们能容忍的时间非确定性越多，我们就越能利用分布式计算。

​		对于“时间在任何地方都以相同的速度前进吗?”这个问题，有三个常见的答案。这些都是:

- 全局时钟    √
- 本地时钟    不是,但是
- 没有时钟    不可以

​		这些大致对应于我在第二章中提到的三个时间假设:同步系统模型有一个全局时钟，部分同步模型有一个本地时钟，而在异步系统模型中根本不能使用时钟。让我们更详细地看看这些。

### 全局时钟假设

​		全球时钟假设是有一个完全精确的全球时钟，每个人都可以使用这个时钟。这是我们思考时间的方式，因为在人类互动中，时间上的微小差异并不重要。

​		![Global clock](http://book.mixu.net/distsys/images/global-clock.png)

​		全局时钟基本上是一个总顺序的来源(所有节点上的每个操作的精确顺序，即使这些节点从未通信)。然而，这是一个理想化的世界:在现实中，时钟同步只能在有限的精度程度上是可能的。这是受限于普通计算机的时钟缺乏准确性，如果使用NTP这样的时钟同步协议，则会有延迟，从根本上说，也受时空性质的限制。

​		假设分布式节点上的时钟是完全同步的，这意味着假设时钟以相同的值开始，并且永远不会漂移(drift apart.)。这是一个很好的假设，因为您可以自由地使用时间戳来确定全局总顺序(受时钟漂移而不是延迟的限制)，但这是一个重要的操作挑战，也是潜在的异常来源。在许多不同的场景中，一个简单的故障——例如用户意外地更改了一台机器的本地时间，或者一台过时的机器加入了集群，或者同步时钟以略微不同的速率漂移，等等，都可能导致难以跟踪的异常。

​		然而，有些真实世界的系统会做出这种假设。Facebook的[Cassandra](http://en.wikipedia.org/wiki/Apache_Cassandra) 就是一个假设时钟是同步的系统。它使用时间戳来解决写操作之间的冲突——具有较新的时间戳的写操作获胜。这意味着如果时钟漂移，新数据可能被忽略或被旧数据覆盖;同样，这是一个操作上的挑战(据我所知，人们也清楚地意识到这一点)。另一个有趣的例子是谷歌的[Spanner](http://research.google.com/archive/spanner.html):论文描述了他们的TrueTime API，它同步时间，但也估计了最坏情况下的时钟漂移。	

### 本地时钟假设

​		第二种可能更合理的假设是，每台机器都有自己的时钟，但没有全球时钟。这意味着您不能使用本地时钟来确定远程时间戳是发生在本地时间戳之前还是之后;换句话说，您不能有意义地比较来自两个不同机器的时间戳。

![Local clock](http://book.mixu.net/distsys/images/local-clock.png)

​		本地时钟的假设更接近于真实世界。它分配了部分顺序:每个系统上的事件是有序的，但不能通过仅使用一个时钟来跨系统对事件进行排序。

​		但是，您可以使用时间戳来将单个机器上的事件进行排序;您可以在单个机器上使用超时，只要您注意不让时钟到处跳。当然，在由最终用户控制的机器上，这可能假设得太多了:例如，用户在使用操作系统的日期控件查找日期时，可能会意外地将其日期更改为不同的值。

### 无时钟假设

​		最后，还有逻辑时间的概念。在这里，我们根本不用时钟，而是用其他方式跟踪因果关系(causality)。请记住，时间戳只是世界到那一点为止的状态的简写(shorthand)——因此我们可以使用计数器和通信来确定某个事件是在其他事件之前、之后还是同时发生的。

​		通过这种方式，我们可以确定不同机器之间的事件顺序，但不能说明间隔，也不能使用超时(因为我们假设没有“时间敏感”)。这是偏序:可以使用计数器在单个系统上对事件进行排序，而不需要通信，但是跨系统对事件进行排序需要进行消息交换。

​		在分布式系统中被引用最多的论文之一是Lamport的《时间、时钟和事件排序》。矢量时钟是这个概念的一种概括(我将更详细地介绍)，是一种不使用时钟跟踪因果关系的方法。卡桑德拉的表兄弟里亚克(Riak，巴索饰)和伏地魔(Voldemort，领英饰)使用的是矢量时钟，而不是假设节点可以访问一个完全精确的全球时钟。这使得这些系统可以避免前面提到的时钟精度问题。

​		当不使用时钟时，可以跨远程机器对事件排序的最大精度受通信延迟的限制。

## 在分布式系统中如何使用时间?

​		最适合的时间是什么?

​		1. 时间可以在一个没有通讯的系统中定义顺序.

​		2. 时间还可以用来定义算法的边界条件

​		事件时间在分布式系统中尤为重要, 许多重要的属性在分布式系统中都是一事件或者是操作时间来定义的.

- 在这种情况下，正确性取决于(协议)正确的事件顺序，例如分布式数据库中的可序列化性

- 当发生资源争用时，顺序可以用作打破僵局的工具，例如，如果一个组件有两个顺序，那么完成第一个顺序，取消第二个顺序

​		全局时钟允许在不直接通信的情况下命令两台不同机器上的操作。如果没有全球时钟，我们需要通过通信来确定秩序。

​		时间还可以用来定义算法的边界条件——特别是，用来区分“高延迟”和“服务器或网络链接断开”。这是一个非常重要的用例;在大多数实际的系统中，超时用于确定远程计算机是否发生故障，或者它是否仅仅经历了高网络延迟。做出这一判断的算法被称为故障检测器;

## 矢量时钟(因果顺序时间)

​		前面，我们讨论了关于分布式系统时间进度的不同假设。假设我们不能实现精确的时钟同步——或者从我们的系统不应该对时间同步问题敏感的目标开始，我们怎么能安排事情呢?

​		Lamport时钟和矢量时钟是物理时钟的替代品，物理时钟依赖计数器和通信来确定分布式系统中的事件顺序。这些时钟提供了一个在不同节点之间具有可比性的计数器。

​		Lamport时钟很简单。每个进程使用以下规则维护一个计数器:

- 每当进程工作时,计数器 + 1
- 每当进程发送消息时,要把计数器也发过去
- 当收到消息时，将计数器设置为max(local_counter, received_counter) + 1

```scala
function LamportClock() {
  this.value = 1;
}

LamportClock.prototype.get = function() {
  return this.value;
}

LamportClock.prototype.increment = function() {
  this.value++;
}

LamportClock.prototype.merge = function(other) {
  this.value = Math.max(this.value, other.value) + 1;
}
```

​		Lamport时钟允许在不同系统之间比较计数器，但有一个警告(caveat):  Lamport时钟定义了一个偏序。如果timestamp(a) < timestamp(b):

​		A可能发生在b之前

​		A可能无法与b相比

  这就是所谓的时钟一致性条件:如果一个事件出现在另一个事件之前，那么该事件的逻辑时钟就出现在其他事件之前。如果a和b来自相同的因果历史，例如，两个时间戳值都是在同一过程中产生的;或者b是对a发送的消息的响应那么我们知道a发生在b之前。	

​		直观地说，这是因为Lamport时钟只能携带一个时间轴/历史的信息;因此，比较从不相互通信的系统的Lamport时间戳可能会导致并发事件看起来是有序的，而实际上它们不是。

​		想象一个系统，在初始阶段之后分成两个独立的子系统，它们彼此之间从不通信。

​		对于每个独立系统中的所有事件，如果a发生在b之前，则ts(a) < ts(b);但如果你从不同的独立系统中选取两个事件(例如，没有因果关系的事件)，那么你就无法对它们的相对顺序做出任何有意义的描述。虽然系统的每个部分都为事件分配了时间戳，但这些时间戳彼此之间没有关系。两个事件可能看起来是有序的，尽管它们并不相关。

​		然而——这仍然是一个有用的属性——从单个机器的角度来看，任何使用ts(a)发送的消息都会收到一个使用ts(b)的响应，它是> ts(a)。

​		一个矢量时钟是Lamport时钟的扩展，它维护一个数组[t1, t2，…]]，每个节点一个。每个节点在每个内部事件上都将向量中自己的逻辑时钟加1，而不是增加一个公共计数器。因此，更新规则是:

- 每当进程工作时，在向量中增加节点的逻辑时钟值
- 每当进程发送消息时，请包含逻辑时钟的完整向量
- 当收到消息时:
  将vector中的每个元素更新为max(本地，已接收)
  递增表示向量中当前节点的逻辑时钟值

```scala
function VectorClock(value) {
  // expressed as a hash keyed by node id: e.g. { node1: 1, node2: 3 }
  this.value = value || {};
}

VectorClock.prototype.get = function() {
  return this.value;
};

VectorClock.prototype.increment = function(nodeId) {
  if(typeof this.value[nodeId] == 'undefined') {
    this.value[nodeId] = 1;
  } else {
    this.value[nodeId]++;
  }
};

VectorClock.prototype.merge = function(other) {
  var result = {}, last,
      a = this.value,
      b = other.value;
  // This filters out duplicate keys in the hash
  (Object.keys(a)
    .concat(b))
    .sort()
    .filter(function(key) {
      var isDuplicate = (key == last);
      last = key;
      return !isDuplicate;
    }).forEach(function(key) {
      result[key] = Math.max(a[key] || 0, b[key] || 0);
    });
  this.value = result;
};
```

![from http://en.wikipedia.org/wiki/Vector_clock](http://book.mixu.net/distsys/images/vector_clock.svg.png)

​		三个节点(A、B、C)中的每个节点都跟踪矢量时钟。当事件发生时，将用矢量时钟的当前值给它们打上时间戳。通过检查向量时钟，如{a: 2, B: 4, C: 1}，我们可以准确地识别(可能)影响该事件的信息。

​		矢量时钟的问题主要是每个节点需要一个条目，这意味着对于大型系统，它们可能变得非常大。已经应用了各种技术来减少矢量时钟的大小(通过执行定期垃圾收集，或通过限制大小来降低精度)。

​		我们已经了解了如何在没有物理时钟的情况下追踪秩序和因果关系。现在，让我们看看如何将时间持续值用于截止。		

## 故障探测器(截止时间)

​		如前所述，等待所花费的时间可以提供有关系统是分区了还是仅仅经历了高延迟的线索。在这种情况下，我们不需要假设一个完全精确的全球时钟——只要有一个足够可靠的本地时钟就足够了。

​		给定一个在一个节点上运行的程序，它如何知道远程节点已经失败?在缺乏准确信息的情况下，我们可以推断，在经过一段合理的时间后，没有响应的远程节点已经失败了。

​		但是什么是“合理的一段时间”呢? 这取决于本地节点和远程节点之间的延迟。与其用特定的值显式地指定算法(在某些情况下，这不可避免地是错误的)，不如处理适当的抽象。

​		故障检测器是一种抽象出精确时间假设的方法。故障检测器使用心跳消息和计时器实现。进程交换心跳消息。如果在超时发生之前没有收到消息响应，则流程会怀疑其他流程。

​		基于超时的故障检测器可能存在过于激进(声明节点已经失败)或过于保守(花很长时间来检测崩溃)的风险。故障检测器需要多精确才能使其可用?

​		Chandra等人(1996)在解决一致性的上下文中讨论了故障检测器——这是一个特别相关的问题，因为它是大多数复制问题的基础，其中副本需要在延迟和网络分区的环境中达成一致。

​		他们用完整性和准确性这两个属性来描述故障检测器:

> Strong completeness.
>
> 每个崩溃的进程最终都会受到每个正确进程的怀疑。
>
> Weak completeness.
>
> 每个崩溃的进程最终都会受到某个正确进程的怀疑。
>
> Strong accuracy.
>
> 没有一个正确的程序是值得怀疑的。
>
> Weak accuracy.
>
> 一些正确的过程是永远不会被怀疑的。

​		完整性比准确性更容易实现;事实上，所有重要的失败探测器都实现了它——你所需要做的就是不要永远等待去怀疑某人。Chandra等人注意到，一个具有弱完备性的故障检测器可以转化为一个具有强完备性的故障检测器(通过广播有关可疑过程的信息)，使我们能够专注于精度特性的频谱。

​		避免错误地怀疑非错误进程是很困难的，除非您能够假定存在消息延迟的硬最大值。这种假设可以在同步系统模型中进行，因此故障检测器在这样的系统中可以非常精确。在没有对消息延迟施加硬性限制的系统模型下，失败检测最多最终是准确的。

​		Chandra等人表明，即使是一个非常弱的故障检测器-最终弱故障检测器⋄W(最终弱精度+弱完整性)-也可以用来解决共识问题。下图(来自论文)说明了系统模型和问题可解性之间的关系:

![From Chandra and Toueg. Unreliable failure detectors for reliable distributed systems. JACM 43(2):225–267, 1996.](http://book.mixu.net/distsys/images/chandra_failure_detectors.png)

​		如上所述，在异步系统中，如果没有故障检测器，某些问题是无法解决的。这是因为如果没有故障检测器(或对时间界限的强大假设，例如同步系统模型)，就不可能判断远程节点是崩溃了，还是仅仅经历了高延迟。这种区别对于任何旨在实现单副本一致性的系统都很重要:可以忽略失败的节点，因为它们不会导致分歧，但不能安全地忽略分区的节点。

​		如何实现故障检测器?从概念上讲，简单的故障检测器并没有太多意义，它只是在超时到期时检测故障。最有趣的部分与如何判断远程节点是否失败有关。

​		理想情况下，我们希望故障检测器能够适应不断变化的网络条件，并避免将超时值硬编码到其中。例如，Cassandra使用一个应计故障检测器，它是一个输出怀疑级别(0到1之间的值)的故障检测器，而不是二进制的“上”或“下”判断。这允许使用故障检测器的应用程序自己决定准确检测和早期检测之间的权衡。

## 时间,顺序和性能

​		如果您正在编写分布式系统，那么您可能拥有不止一台计算机。自然(和现实)的世界观是局部秩序，而不是完全秩序。您可以将部分顺序转换为全部顺序，但这需要通信、等待，并施加限制，限制在任何特定时间点可以工作的计算机数量。

​		所有时钟仅仅是网络延迟(逻辑时间)或物理的近似。即使是在多个节点上保持一个简单的整数计数器同步也是一个挑战。

​		虽然时间和秩序经常一起讨论，但时间本身并不是一个有用的属性。算法并不关心时间，而是更关心更抽象的属性:	

- 事件的因果顺序

- 故障检测(例如，消息传递上界的近似)
- 一致性快照(例如，在某个时间点检查系统状态的能力;不是这里讨论)

​        实行全序是可能的，但代价昂贵。它要求你以普通(最低)的速度进行。通常，确保以某种已定义的顺序交付事件的最简单方法是指定一个(瓶颈)节点，所有操作都通过该节点传递。

​		时间/顺序/同步真的有必要吗?视情况而定。在某些用例中，我们希望每个中间操作将系统从一个一致状态移动到另一个一致状态。例如，在许多情况下，我们希望数据库的响应代表所有可用的信息，并且希望避免处理系统返回不一致结果时可能出现的问题。

​		但在其他情况下，我们可能不需要那么多的时间/顺序/同步。例如，如果您正在运行一个长时间的计算，并且直到最后才真正关心系统在做什么——那么只要您能保证答案是正确的，那么您实际上并不需要太多的同步。

​		当只有一部分情况真正影响最终结果时，同步通常作为一种钝器工具应用于所有操作。什么时候需要秩序来保证正确性?CALM定理——我将在最后一章讨论——提供了一个答案。

​		在其他情况下，给出一个只代表最佳已知估计的答案是可以接受的——也就是说，只基于系统中包含的总信息的一个子集。特别是，在网络分区期间，可能需要在只有部分系统可访问的情况下回答查询。在其他用例中，最终用户无法真正区分可以廉价获得的相对较近的答案和保证正确且计算代价昂贵的答案。例如，某个用户的Twitter关注者数量是X，还是X+1?或者电影A、B和C绝对是某些问题的最佳答案?做一个成本更低，但大部分是正确的“尽最大努力”是可以接受的。

​		在接下来的两章中，我们将研究容错强一致性系统的复制——这些系统提供了强大的保证，同时对故障的恢复能力也越来越强。这些系统为第一种情况提供了解决方案:当您需要保证正确性并愿意为此付费时。然后，我们将讨论具有弱一致性保证的系统，这种系统在分区时仍然可用，但这只能给您一个“最好的努力”的答案。

## 拓展阅读

## Further reading

### Lamport clocks, vector clocks

- [Time, Clocks and Ordering of Events in a Distributed System](http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf) - Leslie Lamport, 1978

### Failure detection

- [Unreliable failure detectors and reliable distributed systems](http://scholar.google.com/scholar?q=Unreliable+Failure+Detectors+for+Reliable+Distributed+Systems) - Chandra and Toueg
- [Latency- and Bandwidth-Minimizing Optimal Failure Detectors](http://www.cs.cornell.edu/people/egs/sqrt-s/doc/TR2006-2025.pdf) - So & Sirer, 2007
- [The failure detector abstraction](http://scholar.google.com/scholar?q=The+failure+detector+abstraction), Freiling, Guerraoui & Kuznetsov, 2011

### Snapshots

- [Consistent global states of distributed systems: Fundamental concepts and mechanisms](http://scholar.google.com/scholar?q=Consistent+global+states+of+distributed+systems%3A+Fundamental+concepts+and+mechanisms), Ozalp Babaogly and Keith Marzullo, 1993
- [Distributed snapshots: Determining global states of distributed systems](http://scholar.google.com/scholar?q=Distributed+snapshots%3A+Determining+global+states+of+distributed+systems), K. Mani Chandy and Leslie Lamport, 1985

### Causality

- [Detecting Causal Relationships in Distributed Computations: In Search of the Holy Grail](http://www.vs.inf.ethz.ch/publ/papers/holygrail.pdf) - Schwarz & Mattern, 1994
- [Understanding the Limitations of Causally and Totally Ordered Communication](http://scholar.google.com/scholar?q=Understanding+the+limitations+of+causally+and+totally+ordered+communication) - Cheriton & Skeen, 1993
